<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Visor de Im√°genes - Estilo Facebook</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@5.4.4/dist/photoswipe.css">


  <!-- Reset y estilos desde CDN -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css/normalize.css">

  <!-- Bootstrap desde CDN -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">

  <!-- Animate.css desde CDN -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css">

  <!-- Google Fonts desde CDN -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap">

  <title>Warp Speed Final</title>
  <style>
 * {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Configuraci√≥n de body y html */
html, body {
  height: 100%;
  /* Eliminamos 'overflow: hidden' del body/html para permitir el scroll en #main */
  overflow-x: hidden; /* Evita el scroll horizontal */
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  background-color: #000000; /* usa solo un color de fondo */
}

/* --- INTRO Y LOGO --- */

#intro {
  position:fixed; inset:0; background:#000000; z-index:9999;
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  transition: opacity 1.4s ease; /* misma transici√≥n para TODO el intro */
}
canvas { position:absolute; top:0; left:0; width:100%; height:100%; }

#logo {
 background-color: rgba(0, 0, 0, 0);
  opacity:0; max-width:82vw; max-height:52vh;
  transform:scale(0.4);
  transition: opacity 1.4s ease-in-out, transform 0.4s cubic-bezier(0.2,1,0.3,1);
  filter: drop-shadow(0 0 70px rgb(0, 0, 0));
  animation: aparecerLogo 2.3s ease-out forwards;
}

@keyframes aparecerLogo {
  0% { opacity: 0; transform: scale(0.5); }
  30% { opacity: 1; transform: scale(1); }
  70% { transform: scale(2.1); }
  100% { transform: scale(2); }
}

#logo.show {
  transition: opacity 1.4s ease-in-out;
   opacity:1; transform:scale(2.2);
}

/* --- TEXTO DEL INTRO --- */

#text {
  margin-top: 10vh;
  /* Usamos clamp para hacer el tama√±o de fuente responsive */
  font: 900 clamp(3.2rem, 13vw, 9rem)/1 'Montserrat', sans-serif;
  color: rgb(224, 224, 224);
  text-shadow: 0 0 40px rgb(0, 132, 255), 0 0 90px rgb(0, 0, 0);
  letter-spacing: 9px;
  opacity: 0;
  text-align: center;
  padding: 0 15px;
  display: inline-block;
  transform-origin: bottom;
}

/* Ajustes de responsive para el texto del intro */
@media (max-width: 768px) {
  #text {
    margin-top: 5vh; /* Menos margen superior en m√≥viles/tablets */
    letter-spacing: 5px;
  }
}

@keyframes aparecerTexto {
  0% { opacity: 0; transform: scaleY(1); }
  30% { opacity: 1; transform: scaleY(2); }
  70% { transform: scaleY(4); }
  100% { transform: scaleY(9); }
}

#text.show {
  opacity:1;
  animation: aparecerTexto 2.5s ease-out forwards;
}

/* --- CONTENIDO PRINCIPAL (#main) --- */

#main {
  /* Habilitamos el scroll vertical en el contenedor principal */
  opacity:0; transition:opacity 1.2s ease;
  min-height:100vh;
  /* El overflow: auto permite el scroll si el contenido excede la altura */
  overflow-y: auto;
  overflow-x: hidden;
  background:#bcbcbc;
  color:white; padding:80px 0; /* Ajuste para que el padding no cause problemas con el scroll */
  text-align:center;
}

/* Secci√≥n principal de la p√°gina */
#page-home {
    padding: 0;
    margin: 0;
    width: 100%;
}

/* T√≠tulo de la p√°gina */
.page-title {
    font-size: 24px;
    font-weight: bold;
    margin-bottom: 0;
    padding: 15px 15px;
    color: #050505;
    background-color: #000000;
    text-align: left; /* Alineaci√≥n a la izquierda */
}

/* Contenedor de la galer√≠a de im√°genes */
.gallery-container {
    display: flex;
    flex-direction: column;
    gap: 0;
}

/* Cada item de la galer√≠a */
.gallery-item {
    cursor: pointer;
    border-radius: 0;
    overflow: hidden;
    background: #000000;
    box-shadow: none;
    border-bottom: 1px solid #e4e6eb;
    transition: background-color 0.2s;
}

.gallery-item:hover {
    background-color: #f7f8fa;
}

/* Imagen dentro del item */
.gallery-item img {
    width: 100%;
    height: auto;
    aspect-ratio: 1 / 1;
    object-fit: cover;
    display: block;
}

/* Descripci√≥n debajo de cada imagen en la galer√≠a */
.gallery-item-description {
    padding: 12px 15px;
    font-size: 14px;
    color: #ffffff;
    line-height: 1.4;
    text-align: left;
}

/* --- MEDIA QUERIES (RESPONSIVE) --- */

/* üíª Escritorio / Pantallas grandes (m√°s de 1200px) */
@media (min-width: 1201px) {
    .gallery-container {
        grid-template-columns: repeat(3, 1fr); /* 3 columnas en escritorio grande */
    }

    .gallery-item:nth-child(2n) {
        border-right: 1px solid #e4e6eb; /* Restaurar borde derecho para la segunda columna */
    }

    .gallery-item:nth-child(3n) {
        border-right: none; /* Sin borde derecho en la tercera columna */
    }

    .page-title {
        font-size: 28px;
        padding: 20px 30px;
    }
}

/* üñ•Ô∏è Escritorio / Tablets horizontales (769px a 1200px) */
@media (min-width: 769px) and (max-width: 1200px) {
    .gallery-container {
        display: grid;
        grid-template-columns: repeat(2, 1fr); /* 2 columnas */
        gap: 0;
    }

    .gallery-item {
        border-right: 1px solid #e4e6eb;
    }

    .gallery-item:nth-child(2n) {
        border-right: none;
    }

    .page-title {
        font-size: 24px;
        padding: 18px 25px;
    }
}


/* üì± Tabletas verticales / M√≥viles grandes (481px a 768px) */
@media (min-width: 481px) and (max-width: 768px) {
    .page-title {
        font-size: 20px;
        padding: 12px 15px;
    }

    /* La galer√≠a se mantiene en una columna por defecto (flex-direction: column) */
    .gallery-item-description {
        padding: 10px 15px;
        font-size: 14px;
    }

    /* Visor */
    .visor-description-container {
        max-height: 120px;
        padding: 15px;
    }

    .visor-close {
        width: 38px;
        height: 38px;
        font-size: 22px;
    }

    .image-visor.active .visor-image-container {
        height: calc(100vh - 120px);
    }
}

/* üì≤ M√≥viles peque√±os (hasta 480px) */
@media (max-width: 480px) {
    .page-title {
        font-size: 18px;
        padding: 10px 12px;
    }

    .gallery-item-description {
        padding: 10px 12px;
        font-size: 13px;
    }

    /* Visor */
    .visor-close {
        width: 36px;
        height: 36px;
        font-size: 20px;
        top: 10px;
        right: 10px;
    }

    .visor-description-container {
        max-height: 100px;
        padding: 12px;
    }

    .visor-description {
        font-size: 14px;
    }

    .image-visor.active .visor-image-container {
        height: calc(100vh - 100px);
    }
}


/* --- C√ìDIGO DEL VISOR (SIN CAMBIOS RELEVANTES EN RESPONSIVE) --- */

/* Visor modal (fondo oscuro) */
.image-visor {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.95);
    z-index: 9999;
    overflow: hidden;
}

.image-visor.active {
    display: flex;
    flex-direction: column;
}

/* Bot√≥n de cerrar (X) */
.visor-close {
    position: absolute;
    top: 15px;
    right: 15px;
    background-color: rgba(68, 73, 80, 0.8);
    border: none;
    border-radius: 50%;
    color: #fff;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10002;
    transition: background-color 0.2s, opacity 0.25s ease-out;
    will-change: opacity;
}

.visor-close.hidden {
    opacity: 0;
    pointer-events: none;
}

.visor-close:hover {
    background-color: rgba(68, 73, 80, 1);
}

/* Contenedor de la imagen con zoom */
.visor-image-container {
    flex: 1;
    position: relative;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    touch-action: none;
    cursor: pointer;
    background-color: #000;
}

/* Wrapper para la transformaci√≥n de la imagen */
.visor-image-wrapper {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Imagen principal del visor */
.visor-image {
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    display: block;
    user-select: none;
    -webkit-user-select: none;
    object-fit: contain;
}

/* Contenedor de la descripci√≥n */
.visor-description-container {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #242526;
    color: #e4e6eb;
    overflow-y: auto;
    transition: transform 0.25s ease-out;
    transform: translateY(0);
    z-index: 10001;
    will-change: transform;
}

.visor-description-container.hidden {
    transform: translateY(100%);
}

.visor-description {
    font-size: 15px;
    line-height: 1.5;
}



  </style>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@900&display=swap" rel="stylesheet">
</head>
<body>

<div id="intro">
  <canvas id="canvas"></canvas>
  <img id="logo" src="leon6.PNG" alt="Logo">
  <div id="text"></div>
</div>

<!--<div id="main"> -->
 <!-- P√°gina principal con galer√≠a de im√°genes -->
 <div id="page-home" class="page-section">
    <h1 class="page-title">Mis Fotos</h1>
    
    <div class="gallery-container" id="galleryContainer">
        <!-- Las im√°genes se generar√°n din√°micamente con JavaScript -->
    </div>
</div>

<!-- Visor de im√°genes modal -->
<div class="image-visor" id="imageVisor">
    <button class="visor-close" id="visorClose" aria-label="Cerrar">&times;</button>
    
    <div class="visor-image-container" id="visorImageContainer">
        <div class="visor-image-wrapper" id="visorImageWrapper">
            <img src="" alt="" class="visor-image" id="visorImage">
        </div>
    </div>
    
    <div class="visor-description-container" id="visorDescriptionContainer">
        <p class="visor-description" id="visorDescription"></p>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/photoswipe@5.4.4/dist/umd/photoswipe.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@5.4.4/dist/umd/photoswipe-lightbox.umd.min.js"></script>







<!--</div>-->



<script>
// COLORES NE√ìN EXACTOS QUE PEDISTE

const neonColors = [
  "#000000", // negro (Fondo principal)
  "#14FFAA", // cian brillante/aguamarina ne√≥n (Acentos principales, l√≠neas, borde del logo)
  "#FFFFFF"
 // "#FF6600", // naranja brillante/rojo ne√≥n (Acento secundario, color del texto "PRODUCTOS DESTACADOS" y las llamas)
  //"#00FFD5", // una variaci√≥n de cian/aguamarina, muy brillante
];







// EFECTO WARP SPEED CON TUS COLORES
const canvas = document.getElementById('canvas'); // Obtiene el elemento Canvas del DOM por su ID.
const ctx = canvas.getContext('2d'); // Obtiene el contexto de renderizado 2D para poder dibujar en el Canvas.
canvas.width = window.innerWidth; // Establece el ancho del Canvas al ancho total de la ventana.
canvas.height = window.innerHeight; // Establece la altura del Canvas a la altura total de la ventana.

const lines = []; // Array que almacenar√° los objetos que representan cada l√≠nea individual.
for(let i = 0; i < 700; i++) { // Bucle para crear 700 l√≠neas.
  lines.push({ // Agrega un nuevo objeto de l√≠nea al array `lines`.
    angle: Math.random() * Math.PI * 2, // Asigna un √°ngulo inicial aleatorio (en radianes) de 0 a 360 grados.
    distance: Math.random() * 100, // Asigna una distancia inicial aleatoria desde el centro (peque√±a, para simular el inicio).
    speed: 5 + Math.random() * 18, // Asigna una velocidad de movimiento aleatoria entre 5 y 23 (5 + 18).
    thickness: Math.random() * 4 + 1, // Asigna un grosor de l√≠nea aleatorio entre 1 y 5.
    color: neonColors[Math.floor(Math.random() * neonColors.length)] // Selecciona un color aleatorio del array `neonColors`.
  });
}

function draw() { // Define la funci√≥n principal de dibujo que se llamar√° en cada fotograma (frame).
  ctx.fillStyle = 'rgba(0,0,0,0.08)'; // Establece el color de relleno del fondo (negro con una ligera opacidad).
  ctx.fillRect(0, 0, canvas.width, canvas.height); // Dibuja un rect√°ngulo que cubre todo el Canvas, creando el efecto de "rastro" o *fade* (difuminado).

  lines.forEach(line => { // Itera sobre cada objeto en el array `lines`.
    line.distance += line.speed; // **Incrementa la distancia de la l√≠nea desde el centro seg√∫n su propiedad `speed`**. Esto simula el movimiento hacia adelante.
    const x = canvas.width/2 + Math.cos(line.angle) * line.distance; // Calcula la coordenada X final de la l√≠nea usando trigonometr√≠a (coseno). El punto de partida es el centro del Canvas.
    const y = canvas.height/2 + Math.sin(line.angle) * line.distance; // Calcula la coordenada Y final de la l√≠nea usando trigonometr√≠a (seno).

    ctx.globalAlpha = Math.min(line.distance / 250, 1); // Calcula la opacidad global (alpha). Aumenta la opacidad cuanto m√°s se aleja la l√≠nea del centro (hasta un m√°ximo de 1).
    ctx.strokeStyle = line.color; // Establece el color del trazo de la l√≠nea.
    ctx.lineWidth = line.thickness * ctx.globalAlpha; // Establece el grosor del trazo, haci√©ndolo m√°s grueso (o fino) seg√∫n la opacidad.
    ctx.beginPath(); // Comienza una nueva ruta de dibujo.
    ctx.moveTo(canvas.width/2, canvas.height/2); // Mueve el punto de inicio de la ruta al centro del Canvas.
    ctx.lineTo(x, y); // Dibuja una l√≠nea desde el centro hasta la posici√≥n calculada (x, y).
    ctx.stroke(); // Aplica el trazo (dibujo) de la l√≠nea con el color y grosor establecidos.

    if (line.distance > Math.max(canvas.width, canvas.height) + 300) { // Comprueba si la l√≠nea ha viajado m√°s all√° de los l√≠mites visibles del Canvas (+ 300 p√≠xeles extra de margen).
      line.distance = 0; // Si ha salido, reinicia la distancia a 0 (vuelve a empezar desde el centro).
      line.angle = Math.random() * Math.PI * 2; // Asigna un nuevo √°ngulo aleatorio para que se dirija en una nueva direcci√≥n.
      line.color = neonColors[Math.floor(Math.random() * neonColors.length)]; // Asigna un nuevo color ne√≥n aleatorio.
    }
  });
  requestAnimationFrame(draw); // Llama a la funci√≥n `draw` de nuevo en el pr√≥ximo ciclo de animaci√≥n del navegador, creando el bucle continuo.
}
draw(); // Llama a la funci√≥n `draw` por primera vez para iniciar la animaci√≥n.

window.addEventListener('resize', () => { // Agrega un "escuchador de eventos" para detectar cuando se cambia el tama√±o de la ventana.
  canvas.width = window.innerWidth; // Ajusta el ancho del Canvas al nuevo ancho de la ventana.
  canvas.height = window.innerHeight; // Ajusta la altura del Canvas a la nueva altura de la ventana.
});

// SECUENCIA PERFECTA
setTimeout(() => { // Establece un temporizador para ejecutar una acci√≥n despu√©s de 800 milisegundos.
  document.getElementById('logo').classList.add('show'); // Obtiene el elemento con ID 'logo' y le a√±ade la clase CSS 'show' para hacerlo aparecer.
}, 700);

setTimeout(() => { // Establece un temporizador para ejecutar una acci√≥n despu√©s de 2000 milisegundos (2 segundos).
  const texto = "EVOLUCION"; // Define el texto que se va a escribir.
  const div = document.getElementById('text'); // Obtiene el elemento con ID 'text'.
  div.classList.add('show');  // A√±ade la clase 'show' para hacerlo visible (seg√∫n el CSS).
  let i = 0; // Inicializa un contador para la posici√≥n del car√°cter actual.
  const type = () => { // Define la funci√≥n recursiva para el efecto de "m√°quina de escribir".
    if (i < texto.length) { // Comprueba si a√∫n quedan caracteres por escribir.
      div.textContent += texto[i++]; // Agrega el siguiente car√°cter del texto al contenido del elemento `div` e incrementa el contador.
      setTimeout(type, 90); // Llama a la funci√≥n `type` de nuevo despu√©s de 90 milisegundos para escribir el siguiente car√°cter.
    }
  };
  type(); // Inicia la funci√≥n de escritura.
}, 1000);

// DESAPARECE TODO JUNTO AL MISMO TIEMPO (7 segundos total)
setTimeout(() => { // Establece un temporizador para ejecutar una acci√≥n despu√©s de 7000 milisegundos (7 segundos).
  const intro = document.getElementById('intro'); // Obtiene el contenedor principal de la introducci√≥n.
  intro.style.opacity = '0';  // Establece la opacidad del contenedor a 0, creando un efecto de *fade out*.
  setTimeout(() => { // Establece un temporizador anidado para ejecutar una acci√≥n despu√©s de 1400 milisegundos (la duraci√≥n del fade out).
    intro.style.display = 'none'; // Una vez que la opacidad es 0, oculta el contenedor por completo para liberar espacio.
    document.getElementById('main').style.opacity = '1'; // Obtiene el elemento con ID 'main' (el contenido principal) y lo hace aparecer (asumiendo que inicialmente ten√≠a opacidad 0).
  }, 1400); // Duraci√≥n del *fade out*.
}, 4000); // Tiempo total de la introducci√≥n antes de que comience el fade out.




  // Datos de ejemplo para las im√°genes
  const imageData = [
            {
                src: 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800',
                description: 'Hermoso paisaje de monta√±as al atardecer con cielo despejado y nubes rosadas.'
            },
            {
                src: 'https://images.unsplash.com/photo-1469474968028-56623f02e42e?w=800',
                description: 'Naturaleza en su m√°ximo esplendor, bosque verde con √°rboles altos.'
            },
            {
                src: 'https://images.unsplash.com/photo-1501594907352-04cda38ebc29?w=800',
                description: 'Playa paradis√≠aca con arena blanca y agua cristalina color turquesa.'
            },
            {
                src: 'https://images.unsplash.com/photo-1475924156734-496f6cac6ec1?w=800',
                description: 'Atardecer en el campo con flores silvestres y cielo naranja.'
            },
            {
                src: 'https://images.unsplash.com/photo-1470071459604-3b5ec3a7fe05?w=800',
                description: 'Lago tranquilo rodeado de monta√±as con reflejo perfecto en el agua.'
            },
            {
                src: 'https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=800',
                description: 'Sendero en el bosque con luz del sol filtr√°ndose entre los √°rboles.'
            }
        ];

        // Referencias a elementos del DOM
        const galleryContainer = document.getElementById('galleryContainer');
        const imageVisor = document.getElementById('imageVisor');
        const visorClose = document.getElementById('visorClose');
        const visorImage = document.getElementById('visorImage');
        const visorDescription = document.getElementById('visorDescription');
        const visorDescriptionContainer = document.getElementById('visorDescriptionContainer');
        const visorImageContainer = document.getElementById('visorImageContainer');
        const visorImageWrapper = document.getElementById('visorImageWrapper');

        // Variables para el manejo de zoom y gestos con PhotoSwipe
        let scale = 1;
        let posX = 0;
        let posY = 0;
        let isDescriptionVisible = true;
        let currentImageIndex = 0;
        
        // Variables para gestos t√°ctiles mejorados
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartDistance = 0;
        let touchStartScale = 1;
        let touchStartPosX = 0;
        let touchStartPosY = 0;
        let isMultiTouch = false;
        let isSingleTouchMove = false;
        let hasMoved = false;
        
        // Variables para detecci√≥n de clics y doble clic
        let lastTapTime = 0;
        let tapTimeout = null;

        // Generar galer√≠a de im√°genes
        function generateGallery() {
            imageData.forEach((item, index) => {
                const galleryItem = document.createElement('div');
                galleryItem.className = 'gallery-item';
                galleryItem.innerHTML = `
                    <img src="${item.src}" alt="Imagen ${index + 1}">
                    <div class="gallery-item-description">${item.description}</div>
                `;
                
                // Evento para abrir el visor al hacer clic
                galleryItem.addEventListener('click', () => openVisor(index));
                galleryContainer.appendChild(galleryItem);
            });
        }

        // Abrir el visor con la imagen seleccionada
        function openVisor(index) {
            const item = imageData[index];
            currentImageIndex = index;
            visorImage.src = item.src;
            visorDescription.textContent = item.description;
            imageVisor.classList.add('active');
            document.body.style.overflow = 'hidden';
            resetZoom();
            showControls();
        }

        // Cerrar el visor
        function closeVisor() {
            imageVisor.classList.remove('active');
            document.body.style.overflow = '';
            resetZoom();
        }

        // Resetear zoom y posici√≥n
        function resetZoom() {
            scale = 1;
            posX = 0;
            posY = 0;
            updateTransform();
        }

        // Actualizar transformaci√≥n de la imagen
        function updateTransform() {
            visorImageWrapper.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
            visorImageWrapper.style.transition = (isMultiTouch || isSingleTouchMove) ? 'none' : 'transform 0.25s ease-out';
        }

        // Mostrar controles (descripci√≥n y bot√≥n X)
        function showControls() {
            isDescriptionVisible = true;
            visorDescriptionContainer.classList.remove('hidden');
            visorClose.classList.remove('hidden');
        }

        // Ocultar controles (descripci√≥n y bot√≥n X)
        function hideControls() {
            isDescriptionVisible = false;
            visorDescriptionContainer.classList.add('hidden');
            visorClose.classList.add('hidden');
        }

        // Toggle de controles con detecci√≥n de clic simple (solo desktop)
        visorImageContainer.addEventListener('click', (e) => {
            // Solo funciona en desktop (no en touch)
            if (e.pointerType === 'mouse' || (!('ontouchstart' in window) && e.type === 'click')) {
                const currentTime = new Date().getTime();
                const timeSinceLastTap = currentTime - lastTapTime;
                
                // Detectar doble clic
                if (timeSinceLastTap < 300 && timeSinceLastTap > 0) {
                    e.preventDefault();
                    clearTimeout(tapTimeout);
                    handleDoubleClick(e);
                    lastTapTime = 0;
                    return;
                }
                
                // Clic simple - esperar para ver si viene otro
                lastTapTime = currentTime;
                clearTimeout(tapTimeout);
                
                tapTimeout = setTimeout(() => {
                    if (scale === 1 && !isMultiTouch && !isSingleTouchMove) {
                        toggleControls();
                    }
                    lastTapTime = 0;
                }, 300);
            }
        });
        
        // Prevenir el comportamiento por defecto de iOS que causa zoom
        visorImageContainer.addEventListener('gesturestart', (e) => {
            e.preventDefault();
        });
        
        visorImageContainer.addEventListener('gesturechange', (e) => {
            e.preventDefault();
        });
        
        visorImageContainer.addEventListener('gestureend', (e) => {
            e.preventDefault();
        });
        
        // Funci√≥n para alternar controles
        function toggleControls() {
            if (isDescriptionVisible) {
                hideControls();
            } else {
                showControls();
            }
        }
        
        // Funci√≥n para manejar doble clic
        function handleDoubleClick(e) {
            if (scale === 1) {
                // Hacer zoom in al 2.5x
                const rect = visorImageContainer.getBoundingClientRect();
                const clickX = e.clientX || e.touches?.[0]?.clientX || rect.width / 2;
                const clickY = e.clientY || e.touches?.[0]?.clientY || rect.height / 2;
                
                scale = 2.5;
                
                // Centrar el zoom en el punto del clic
                const offsetX = (rect.width / 2 - clickX) * (scale - 1);
                const offsetY = (rect.height / 2 - clickY) * (scale - 1);
                
                posX = offsetX;
                posY = offsetY;
                
                updateTransform();
            } else {
                // Volver al tama√±o original
                scale = 1;
                posX = 0;
                posY = 0;
                updateTransform();
            }
        }

        // Evento para cerrar el visor
        visorClose.addEventListener('click', closeVisor);

        // Cerrar al hacer clic en el fondo (solo si no hay zoom)
        imageVisor.addEventListener('click', (e) => {
            if (e.target === imageVisor && scale === 1) {
                closeVisor();
            }
        });

        // Cerrar con la tecla Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && imageVisor.classList.contains('active')) {
                closeVisor();
            }
        });

        // Manejo de eventos t√°ctiles mejorado para pinch-to-zoom fluido
        visorImageContainer.addEventListener('touchstart', (e) => {
            const touches = e.touches;
            hasMoved = false;
            
            if (touches.length === 2) {
                // Inicio del gesto de pinch
                e.preventDefault();
                isMultiTouch = true;
                isSingleTouchMove = false;
                clearTimeout(tapTimeout);
                
                touchStartDistance = getDistance(touches[0], touches[1]);
                touchStartScale = scale;
                
                touchStartPosX = posX;
                touchStartPosY = posY;
                
            } else if (touches.length === 1) {
                // Inicio de un toque simple
                isMultiTouch = false;
                isSingleTouchMove = false;
                
                touchStartX = touches[0].clientX;
                touchStartY = touches[0].clientY;
                touchStartPosX = posX;
                touchStartPosY = posY;
            }
        }, { passive: false });

        visorImageContainer.addEventListener('touchmove', (e) => {
            const touches = e.touches;
            
            // Detectar si hubo movimiento significativo (m√°s de 10px)
            if (touches.length === 1 && !isMultiTouch) {
                const deltaX = Math.abs(touches[0].clientX - touchStartX);
                const deltaY = Math.abs(touches[0].clientY - touchStartY);
                if (deltaX > 10 || deltaY > 10) {
                    hasMoved = true;
                }
            } else {
                hasMoved = true;
            }
            
            if (touches.length === 2 && isMultiTouch) {
                // Gesto de pinch en progreso
                e.preventDefault();
                
                const currentDistance = getDistance(touches[0], touches[1]);
                const scaleChange = currentDistance / touchStartDistance;
                
                scale = touchStartScale * scaleChange;
                scale = Math.max(1, Math.min(scale, 5)); // Limitar entre 1x y 5x
                
                // Si llegamos a escala 1, resetear posici√≥n
                if (scale <= 1.01) {
                    scale = 1;
                    posX = 0;
                    posY = 0;
                }
                
                updateTransform();
                
            } else if (touches.length === 1 && scale > 1) {
                // Arrastrar la imagen cuando est√° con zoom
                e.preventDefault();
                isSingleTouchMove = true;
                
                const deltaX = touches[0].clientX - touchStartX;
                const deltaY = touches[0].clientY - touchStartY;
                
                posX = touchStartPosX + deltaX;
                posY = touchStartPosY + deltaY;
                
                // Limitar el arrastre para que no se salga demasiado
                const maxOffset = 200;
                posX = Math.max(-maxOffset * scale, Math.min(maxOffset * scale, posX));
                posY = Math.max(-maxOffset * scale, Math.min(maxOffset * scale, posY));
                
                updateTransform();
            }
        }, { passive: false });

        visorImageContainer.addEventListener('touchend', (e) => {
            const wasMultiTouch = isMultiTouch;
            const wasSingleTouchMove = isSingleTouchMove;
            
            // Si no se movi√≥ y es un tap simple (no fue pinch ni arrastre)
            if (!hasMoved && e.touches.length === 0 && !wasMultiTouch && !wasSingleTouchMove) {
                e.preventDefault();
                e.stopPropagation();
                
                const currentTime = new Date().getTime();
                const timeSinceLastTap = currentTime - lastTapTime;
                
                // Detectar doble tap (menos de 400ms para iOS)
                if (timeSinceLastTap < 400 && timeSinceLastTap > 50 && lastTapTime > 0) {
                    // Doble tap detectado
                    clearTimeout(tapTimeout);
                    
                    const touch = e.changedTouches[0];
                    handleDoubleClick({ 
                        clientX: touch.clientX, 
                        clientY: touch.clientY 
                    });
                    lastTapTime = 0;
                } else {
                    // Tap simple - esperar para ver si viene otro
                    lastTapTime = currentTime;
                    clearTimeout(tapTimeout);
                    
                    // Timeout m√°s largo para iOS (350ms)
                    tapTimeout = setTimeout(() => {
                        if (scale === 1) {
                            toggleControls();
                        }
                        lastTapTime = 0;
                    }, 350);
                }
            }
            
            // Resetear flags despu√©s de un peque√±o delay
            if (e.touches.length === 0) {
                setTimeout(() => {
                    isMultiTouch = false;
                    isSingleTouchMove = false;
                    hasMoved = false;
                }, 150);
                
                // Si la escala es muy cercana a 1, resetear completamente
                if (scale < 1.1 && scale !== 1) {
                    scale = 1;
                    posX = 0;
                    posY = 0;
                    updateTransform();
                }
            }
        }, { passive: false });

        // Soporte para zoom con rueda del mouse (desktop)
        visorImageContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const delta = e.deltaY * -0.005;
            const rect = visorImageContainer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const oldScale = scale;
            scale += delta;
            scale = Math.max(1, Math.min(5, scale));
            
            if (scale > 1) {
                // Ajustar posici√≥n bas√°ndose en la posici√≥n del mouse
                const scaleChange = scale / oldScale;
                posX = mouseX - (mouseX - posX) * scaleChange;
                posY = mouseY - (mouseY - posY) * scaleChange;
            } else {
                posX = 0;
                posY = 0;
            }
            
            updateTransform();
        }, { passive: false });

        // Funci√≥n auxiliar para calcular distancia entre dos puntos t√°ctiles
        function getDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Inicializar la galer√≠a al cargar la p√°gina
        generateGallery();








</script>
</body>
</html>
